---
title: "Manually parsing the McStas DSL"
---


Text Parsing is Fun

At some point, while researching and learning how to write things in C, I happened upon custom parsing and thought it was amazing. Turns out that people have been manually parsing many things since way back when, and done it very well.

Parsing has perhaps gotten a bad rep, afterall, it seems like something that "should just work". Or at the very least, something that we should have tools for.

Indeed, plenty of tools were written in the 1970s and given names like Yacc and Bison. Presumably because these animals, are related to the infamous GNU, the quintessential software hoofed animal.

At a closer look, parsing isn't only about making the computer read JSON files or used by corporations to write C compilers, supposedly a common practice in the 70's and 80's. Rather it might just owe its claim to fame to one of the wildest and most hoofed programming paradigms: META programming.

Meta programming wasn't built into C, which lacks "reflection", a very relevant programming language feature. In an attempt to explain the importance of meta programming to a non-programmer, I'd point to the widespread usage of scripting languages like Python, JavaScript, Ruby, and, handed down from ancient times, Perl. All very wide-spread, and with this capacity.


What even is META Programming?

The ability to write a program that writes ANOTHER program. This is admittedly a two-step process: First you write and execute code that outputs program code. Finally you compile and execute that. Notice what we did there? We wrote a META program, the second step kind of happened on its own.

With meta programming, you can simply configure certain things abstractly, and let the meta process take its course, rather than writing it all out in tedious detail.

If all of this sounds a bit complicated, well, it is: Many meta programs are indeed incomprehensible to anyone but their authors, and their knowledge will probably die with them. Meta programs tend to be a bit like convoluted math proofs that skip way too many steps.

Despite the obscurity trap, meta programming comes with enormous power, and allows us to do many things in a quite clever and time-saving way.


Overly Contrived Example:

Also McStas, a physics simulation package originally dating from 1997, was indeed written by people wielding the power of META. As a physics simulation, performance requirements dictated that McStas was written in C, not Perl, and thus the meta program had to output C code.

Why not write the meta program in C too, then? This was not uncommon back then, and lets us now circle back to those furry software animals mentioned above, specifically BISON and FLEX.

The BISON/FLEX combo is known as a parser generator. It is not just a parser, nor is it just a code generator. It is a parser that generates another parser, or rahter, it outputs C source code that is compiled into a parser.

Let's break down how this works:

In the BISON/FLEX system you write rules that dictate how input text must be structured to be accepted as a valid (abstract, configuration) meta program - meaning the exact words, sentences and sequences that are allowed.

For example, let's insist that an email must contain the following elements:

"email: greeting body farewell"

Breaking it down further, the "greeting" could be defined as

"greeting: formality name"
"body: TEXT"
"farewell: formality2 name

Then we must go on to explain what "formality" and "name" refer to, and so on and so forth. At some point, we will have described everything to the required degree for our purposes.

Notice how the rules above are written in an abstract and beautiful way that resembles mathematics.


What is it all for? Experiment Physics Cross-over

Imagine that you are an experimental physicist with sporadic access to highly expensive and complex equipment. You don't have time to practice on the actual equipment, but it must still be configured exactly right for the experiment to be a success. 

In order to solve this connundrum, you simulate the experiment in software, which allows you to plan and tweak the actual experiment. The simulation could show you how to configure the equipment optimally.

Since simulation code is fickle and complicated, you'd want to configure / arrange pre-existing software components that match the physical instrument as closely as possible, and not write the whole simulation program from scratch.

Which people actually did for years - until better options like McStas were developed.

So they created a way to configure the simulation and express the instrument in terms of pre-written components, essentially tidbits of custom C code. The components themselves were configurable, and it was fairly easy to create new components to enter into the system.

To keep it all neat and tight, they used BISON/FLEX to create a parser that would convert an instrument configuration file into a complete and finished simulation program for your exact instrument.


McStas is great, but ...

This software strategy was a great success, and there is nothing bad to say about it, really. As all software projects though, it has its issues and unwanted limitations, as well as vectors of potential improvement.

Presented below are three major issues with the system as-is, as well as a proposed fix.

The FLEX/BISON setup is rather convoluted. In order to use it, you need a few "grammar rules" and "lexer" files, which must be stored in the project. The flex/bison command-line tools take these configuration files as their input, and outputs the C code which comprise the actual DSL parser.

This takes a few steps, so when debugging any changes to the configuration, you have to go through the entire build process:

1) edit the flex/bison configuration files ->
2) execute flex/bison cli tools ->
3) include the generated parser code into the 'mcstas' tool and compile ->
4) run the generated mcstas parser-tool on a sample instrument file ->
5) the mcstas parser how outputs source code for the simulation ->
6) compile the simulation source ->
7) run the executable and check this simulation's output files (using other tools)

This process can be automated, sure, but we may be hard pressed to use this level of automation and still retain a convenient development setup.

Problem a) The lack of a convenient development process.

We also can't debug the parser, because the flex/bison .y and .l files can't be debugged, and the resulting parser code is incomprehensible, very recursive and nested, and not to be trifled with.

Problem b) Error messages are very generic

Another consequence of this degree of automation, is that the error codes the generated parser outputs are quite generic.

This means that when new (and even experienced) users work with their instruments, they may have a hard time figuring out what that cryptic error message even means. Sure it isn't terrible, but it leaves a lot to be desired in terms of usability.

Problem c) Inaccessible simulation core algorithms

The biggest problem with the current mcstas setup, in my personal opinion, is the inaccessibility of the core algorithms.

For years, mcstas has run essentially the same simulation ray tracing loop. At some point, MPI was introduced, and it has also been ported to GPUs with a tool called OpenACC. To make the OpenACC port possible, we had to heavily edit the code generator, again using the long-winded process sketched above.

It bears mentioning that the mcstas code generator is indeed tightly linked to the parser, since part of the job of the parser is to collect data, and set it up in a convenient way for later code geneartion.

Both brought significant performance improvements, but came at a steep complexity cost.

Experimenting with, and changing the core algorithms was a slow and arduous process. If we, the core developers, couldn't do it, it was a sure bet that the users wouldn't. Changes to the parser/DSL were atomic and sporadic, and core algorithms stayed essentially the same.


Can such a Legacy be "Fixed"?

The assumption was always that writing a parser - and thus another code generator as well - in any other way, was either unfeasible or unviable in terms of time invested.

So for 25 years, the ring build-system lay dormant at the bottom of the Rhine, awaiting the programmers to reclaim it ...

People have thus built tools ON TOP OF the un-touchable mcstas core and developed onion rings of software stack on top of it. (As you do.) And mostly these days, the basic simulation tools seem to be happily ignored, which is presumably fine for the present purposes.

What about those forgotten ground-layers or code, though? For whatever reason, I started writing a parser for the mcstas DSL during the Corona crisis. It was such a delightful experience, and a few months ago I took up the project and continued the work.

Finally today, we have a working prototype of 'mcparse', a custom mcstas DSL parser with 95% language coverage.

To prove its validity, I wrote a code generator to match. In the 'mctrace' project, this generated code is combined with other custom algorithms and tools to produce real run-time simulation output and graphics.

It combines partially with the mcstas simulation core, also salvaged from the McCode project, and with custom ray-tracing procedures. This is described elsewhere, for now just an assertion that a working, proof-of-concept code-generator and simulation core exists.


What Custom parsing brings to the table


Here's to the example outputs





